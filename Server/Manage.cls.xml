<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Server.Manage">
<Super>%RegisteredObject</Super>
<TimeCreated>62878,65398.283255</TimeCreated>

<Method name="CommandRun">
<ClassMethod>1</ClassMethod>
<FormalSpec>Command,GlobalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set Status=$$$OK
	Try {
	k @GlobalName
	Set Log=##Class(%Library.File).TempFilename("log")
	If $$$isVMS {
	Set Status=$zf(-1,Command,Log)
	} Else {
	Set Status=$zf(-1,Command_" >"_Log)
	}
	Open Log:"RSD":5 If '$t return $$$ERROR($$$FileNotFound,Log)
	Set Status=$$$OK
	Set IO=$I
	Use Log
	Set Count=0
	For {
	Read Record Quit:$zeof
	Set Count=Count+1
	Set GlobalRef=GlobalName_"("_Count_")"
	Set @GlobalRef=Record
	}
	} Catch e {
		s sc=e.AsStatus()
	}
	If $d(Log)
	Close Log
	If $d(IO)
	Use IO
 quit Status
]]></Implementation>
</Method>

<Method name="SafeCmd">
<Description>
убираем из командной строки многие команды
оставляем только разрешенные команды</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>cmd</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set cmd=$piece(cmd,"&&")  // оставляем одну команду
	set cmd=$piece(cmd,"|")
	for i="dir","type","ver","cd" set safe(i)=""  // список разрешенных команд
	if '$data(safe($piece(cmd," "))) set cmd=""   
	quit cmd
]]></Implementation>
</Method>

<Method name="RunCmd">
<Description>
выполнить команду на сервере и сложить результат в глобал ad так, что:
@ad=количество строк
@ad@(номер строки)=значениеa</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>cmd,ad:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sc=$$$OK
	do $SYSTEM.Process.SetZEOF(1)   	// выключаем режим генерации ошибки на EOF
	// делаем командную строку безопасной
	set cmd(1)=..SafeCmd(cmd) 
	quit:cmd(1)="" $$$ERROR($$$GeneralError,"Недопустимая команда "_cmd)
	set cmd=cmd(1)
	// очищаем присланный глобал
	kill @ad
	set count=0

	try {
	open cmd:"QR" if '$test  $$$ThrowStatus($$$ERROR($$$GeneralError,"Не удалось выполнить команду "_cmd))
	Set IO=$IO  // запоминаем текущее устройство
	// вычитываем построчно результат команды пока не наступит конец файла и складываем его в глобал
	for  { 
		use cmd 
		read str quit:$zeof=-1
		set @ad@($Increment(count))=str
		}
	set @ad=count
	// закрываем устройство 
	#dim e as %Exception.AbstractException
	} Catch e {
			set sc=e.AsStatus()
			do e.Log()   // 
	}
	// закрываем устройство 
	close cmd

	// возвращаем текущее устройство
	If $data(IO) Use IO
 quit sc
]]></Implementation>
</Method>
</Class>
</Export>
